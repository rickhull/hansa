require 'hansa/goods'
require 'hansa/city_types'
require 'matrix'

module Hansa
  class City
    class LaborShortfall < RuntimeError; end

    MODIFIED = {}

    # apply modifier to LABOR; return a new hash
    def self.modify(type = :developing)
      cached = MODIFIED[type]
      return cached unless cached.nil?
      mods = TYPES.fetch type
      hsh = {}
      Goods::LABOR.each { |good, labor|
        m = mods[good] || 1
        hsh[good] = [1, labor * m].max
      }
      hsh
    end

    # generate a LABOR-like hash with modifications and disturbances
    def self.terrain(type = :developing)
      hsh = {}
      self.modify(type).each { |good, labor|
        delta = labor * (rand(0) - 0.5) / 2
        hsh[good] = [1, (labor + delta).round].max
      }
      hsh
    end

    # diminishing marginal utility
    # 0.9 <= DMU <= 1.0
    def self.dmu(pop)
      if pop <= 10
        0.9
      elsif pop <= 100
        0.92
      elsif pop <= 1000
        0.95
      elsif pop <= 5000
        0.965
      elsif pop <= 10_000
        0.98
      elsif pop <= 100_000
        0.99
      else
        0.999
      end
    end

    # increasing complementary utility
    # 1.0 <= ICU <= 1.1
    def self.icu(pop)
      if pop <= 10
        1.1
      elsif pop <= 100
        1.05
      elsif pop <= 1000
        1.001
      elsif pop <= 5000
        1.0001
      elsif pop <= 10_000
        1.00002
      elsif pop <= 100_000
        1.00001
      else
        1.000005
      end
    end

    def self.labor_check!(labor, pop)
      if labor > pop
        raise(LaborShortfall,
              format("pop %i cannot support labor %i", pop, labor))
      end
      labor
    end

    attr_accessor :name, :pop, :dmu, :icu
    attr_reader :terrain, :type

    def initialize(name: 'Hansa', pop: 10_000, type: :developing)
      @name = name
      @pop = pop
      @dmu = self.class.dmu(@pop)
      @icu = self.class.icu(@pop)
      self.type = type
    end

    def to_s
      format("%s, pop: %i%s\tDMU: %.3f ICU: %.5f",
             @name, @pop, (@type ? " (#{@type})" : ''), @dmu, @icu)
    end

    # regenerate terrain when changing city type
    def type=(val)
      @terrain = self.class.terrain(val)
      @type = val
    end

    # how much labor is required to produce e.g.
    #   apple: 2 units
    #   bread: 5 units
    def labor(goods_hsh)
      labor = {}
      goods_hsh.each { |good, count|
        labor[good] = count * @terrain.fetch(good)
      }
      labor
    end

    # how much utility is generated by e.g.
    #   apple: 2 units
    #   bread: 5 units
    def utility(goods_hsh)
      total_goods = goods_hsh.values.sum
      utility = {}
      goods_hsh.each { |good, count|
        other_goods = total_goods - count
        utils = Goods::CONSUMPTION.fetch(good)
        # for every util, add them up
        utility[good] = Array.new(count) { |i|
          # the multiplier gets smaller as i goes up
          utils * (@dmu ** i)
        }.sum * (@icu ** other_goods)
      }
      utility
    end

    # given different amounts of different goods
    # show the expected labor required and utility generated, e.g.
    #   apple: 2 units
    #   bread: 5 units
    def propose(goods_hsh)
      labor = self.labor(goods_hsh)
      total_labor = labor.values.sum
      leisure = @pop - total_labor
      self.class.labor_check!(total_labor, @pop)
      utility = self.utility(goods_hsh)
      Hash[labor: labor,
           total_labor: total_labor,
           utility: utility,
           total_utility: utility.values.sum,
           leisure: leisure]
    end

    # expected production (good => units) aka "basket" from e.g.
    #   apple: 10 labor assigned
    #   bread:  5 labor assigned
    def allocate(goods_labor)
      total_labor = self.class.labor_check!(goods_labor.values.sum, @pop)
      hsh = {}
      goods_labor.each { |good, labor|
        # how many units can we produce for this good?
        hsh[good] = (labor / @terrain.fetch(good)).floor
      }
      hsh[:leisure] = @pop - total_labor
      hsh
    end

    # based on @terrain, sort by utils per labor
    def advisor(pow = 1)
      hsh = {}
      @terrain.each { |good, labor|
        utils = Goods::CONSUMPTION.fetch(good)
        hsh[good] = utils.to_f / labor ** pow
      }
      hsh.sort_by { |k, v| -1 * v }.to_h
    end
  end
end
